<snippet>
	<content><![CDATA[
template<class T, class F>
struct persistent_segment_tree{
	int n;
	vector<int> left, right;
	vector<T> data;
	F TT; // monoid operation (always adjacent)
	T T_id; // monoid identity
	persistent_segment_tree(int n, F TT, T T_id): persistent_segment_tree(vector<T>(n, T_id), TT, T_id){ }
	persistent_segment_tree(int n, T init, F TT, T T_id): persistent_segment_tree(vector<T>(n, init), TT, T_id){ }
	persistent_segment_tree(const vector<T> &a, F TT, T T_id): n((int)a.size()), TT(TT), T_id(T_id){
		build(a);
	}
	int last_state(){
		return (int)data.size() - 1;
	}
	int new_state(int l, int r, T x){
		left.push_back(l), right.push_back(r), data.push_back(x);
		return last_state();
	}
	// O(n)
	int build(const vector<T> &a){
		auto recurse = [&](auto self, int l, int r){
			if(r - l == 1) return new_state(-1, -1, a[l]);
			int m = l + (r - l >> 1);
			int v = self(self, l, m), w = self(self, m, r);
			return new_state(v, w, TT(data[v], data[w]));
		};
		return recurse(recurse, 0, (int)a.size());
	}
	// O(log n)
	int set(int u, int p, T x){
		auto recurse = [&](auto self, int u, int l, int r){
			if(r - l == 1) return new_state(-1, -1, x);
			int m = l + (r - l >> 1), v = left[u], w = right[u];
			if(p < m) v = self(self, v, l, m);
			else w = self(self, w, m, r);
			return new_state(v, w, TT(data[v], data[w]));
		};
		return recurse(recurse, u, 0, n);
	}
	// O(log n)
	T query(int u, int ql, int qr){
		auto recurse = [&](auto self, int u, int l, int r){
			if(qr <= l || r <= ql) return T_id;
			if(ql <= l && r <= qr) return data[u];
			int m = l + (r - l >> 1);
			return TT(self(self, left[u], l, m), self(self, right[u], m, r));
		};
		return recurse(recurse, u, 0, n);
	}
};
]]></content>
	<!-- Optional: Set a tabTrigger to define how to trigger the snippet -->
	<tabTrigger>persistent_segment_tree</tabTrigger> -->
	<!-- Optional: Set a scope to limit where the snippet will trigger -->
	<scope>source.c++</scope> -->
</snippet>
