<snippet>
	<content><![CDATA[
template<class B, class T, class U, class F1, class F2, class F3, class F4>
struct dynamic_lazy_segment_tree{
	B n; // exclusive upper bound of coordinate
	vector<int> left, right;
	vector<T> data;
	vector<U> updates;
	F1 TT; // monoid operation (always adjacent)
	T T_id; // monoid identity
	F2 T_init;
	F3 UU; // monoid operation (superset, subset)
	U U_id; // monoid identity
	F4 UT; // action of U on T (superset, subset)
	dynamic_lazy_segment_tree(B n, F1 TT, T T_id, F2 T_init, F3 UU, U U_id, F4 UT): n(n), TT(TT), T_id(T_id), T_init(T_init), UU(UU), U_id(U_id), UT(UT){
		new_state(-1, -1, T_init(0, n), U_id);
	}
	void extend(int u, B l, B r){
		if(!~left[u]){
			B m = l + (r - l >> 1);
			left[u] = new_state(-1, -1, T_init(l, m), U_id);
			right[u] = new_state(-1, -1, T_init(m, r), U_id);
		}
	}
	void push(int u, B l, B r){
		int m = l + (r - l >> 1), v = left[u], w = right[u];
		data[v] = UT(updates[u], data[v]);
		updates[v] = UU(updates[u], updates[v]);
		data[w] = UT(updates[u], data[w]);
		updates[w] = UU(updates[u], updates[w]);
		updates[u] = U_id;
	}
	void refresh(int u, B l, B r){
		data[u] = UT(updates[u], TT(data[left[u]], data[right[u]]));
	}
	int last_state(){
		return (int)data.size() - 1;
	}
	int new_state(int v, int w, T x, U y){
		left.push_back(v), right.push_back(w), data.push_back(x), updates.push_back(y);
		return last_state();
	}
	// O(log(n))
	void update(B ql, B qr, U x){
		assert(0 <= ql && ql <= qr && qr <= n);
		auto recurse = [&](auto recurse, int u, B l, B r)->void{
			if(qr <= l || r <= ql) return;
			if(ql <= l && r <= qr){
				data[u] = UT(x, data[u]), updates[u] = UU(x, updates[u]);
				return;
			}
			extend(u, l, r), push(u, l, r);
			B m = l + (r - l >> 1);
			recurse(recurse, left[u], l, m), recurse(recurse, right[u], m, r);
			refresh(u, l, r);
		};
		recurse(recurse, 0, 0, n);
	}
	// O(log(n))
	T query(B ql, B qr){
		assert(0 <= ql && ql <= qr && qr <= n);
		auto recurse = [&](auto recurse, int u, B l, B r)->T{
			if(qr <= l || r <= ql) return T_id;
			if(ql <= l && r <= qr) return data[u];
			extend(u, l, r), push(u, l, r);
			B m = l + (r - l >> 1);
			return TT(recurse(recurse, left[u], l, m), recurse(recurse, right[u], m, r));
		};
		return recurse(recurse, 0, 0, n);
	}
	// pred(sum[l, r)) is T, T, ..., T, F, F, ..., F
	// Returns max r with T
	// O(log(n))
	B max_pref(B ql, auto pred){
		assert(pred(T_id));
		if(ql == n) return ql;
		T pref = T_id;
		auto recurse = [&](auto self, int u, B l, B r)->B{
			if(r <= ql) return -1;
			if(ql <= l && pred(TT(pref, data[u]))){
				pref = TT(pref, data[u]);
				return -1;
			}
			if(r - l == 1) return l;
			extend(u, l, r), push(u, l, r);
			B m = l + (r - l >> 1), p = self(self, left[u], l, m);
			return ~p ? p : self(self, right[u], m, r);
		};
		B qr = recurse(recurse, 0, 0, n);
		if(!~qr) qr = n;
		return qr;
	}
	// pred(sum[l, r)) is F, F, ..., F, T, T, ..., T
	// Returns min l with T
	// O(log(n))
	B min_suff(B qr, auto pred){
		assert(pred(T_id));
		if(qr == 0) return qr;
		T suff = T_id;
		auto recurse = [&](auto self, int u, B l, B r)->B{
			if(qr <= l) return -1;
			if(r <= qr && pred(TT(data[u], suff))){
				suff = TT(data[u], suff);
				return -1;
			}
			if(r - l == 1) return r;
			extend(u, l, r), push(u, l, r);
			B m = l + (r - l >> 1), p = self(self, right[u], m, r);
			return ~p ? p : self(self, left[u], l, m);
		};
		B ql = recurse(recurse, 0, 0, n);
		if(!~ql) ql = 0;
		return ql;
	}
	template<class output_stream>
	friend output_stream &operator<<(output_stream &out, dynamic_lazy_segment_tree<B, T, U, F1, F2, F3, F4> seg){
		out << "[";
		for(auto i = 0; i < seg.n; ++ i){
			out << seg.query(i, i + 1);
			if(i != seg.n - 1) out << ", ";
		}
		return out << ']';
	}
};
]]></content>
	<!-- Optional: Set a tabTrigger to define how to trigger the snippet -->
	<tabTrigger>dynamic_lazy_segment_tree</tabTrigger> -->
	<!-- Optional: Set a scope to limit where the snippet will trigger -->
	<scope>source.c++</scope> -->
</snippet>
