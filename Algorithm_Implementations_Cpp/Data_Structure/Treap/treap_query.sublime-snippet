<snippet>
	<content><![CDATA[
template<class T, class F>
struct treap_query{
	vector<unsigned int> priority;
	vector<int> pv, left, right, internal_size;
	vector<T> data, subtr_data;
	F TT; // monoid operation (always adjacent)
	T T_id; // monoid identity
	vector<int> dead_node;
	treap_query(F TT, T T_id): TT(TT), T_id(T_id){ }
	template<bool UPDATE_STRUCTURE = true>
	void refresh(int u){
		if constexpr(UPDATE_STRUCTURE){
			pv[u] = -1;
			internal_size[u] = 1;
		}
		subtr_data[u] = T_id;
		if(auto v = left[u]; ~v){
			if constexpr(UPDATE_STRUCTURE){
				pv[v] = u;
				internal_size[u] += internal_size[v];
			}
			subtr_data[u] = subtr_data[v];
		}
		subtr_data[u] = TT(subtr_data[u], data[u]);
		if(auto w = right[u]; ~w){
			if constexpr(UPDATE_STRUCTURE){
				pv[w] = u;
				internal_size[u] += internal_size[w];
			}
			subtr_data[u] = TT(subtr_data[u], subtr_data[w]);
		}
	}
	void heapify(int u){
		if(~u){
			int v = u;
			if(~left[u] && priority[left[u]] > priority[v]) v = left[u];
			if(~right[u] && priority[right[u]] > priority[v]) v = right[u];
			if(u != v) swap(priority[u], priority[v]), heapify(v);
		}
	}
	template<class output_stream>
	output_stream &print(output_stream &out, int root){
		#ifdef LOCAL
		out << "[";
		traverse(root, [&](int u){ out << data[u] << ", "; });
		out << "\b\b]\n";
		#endif
		return out;
	}
	int new_node(const T &x, int v = -1, int w = -1){
		// Among all seeds in range [0, 1769666],
		// 72718 has the longest sequence of unique numbers of length 362129.
		static mt19937 rng(72718);
		int u;
		if(dead_node.empty()){
			u = (int)data.size();
			pv.push_back(-1);
			left.push_back(v);
			right.push_back(w);
			priority.push_back(rng());
			internal_size.push_back(1);
			data.push_back(x);
			subtr_data.push_back(x);
		}
		else{
			u = dead_node.back();
			dead_node.pop_back();
			pv[u] = -1;
			left[u] = v;
			right[u] = w;
			priority[u] = rng();
			internal_size[u] = 1;
			data[u] = x;
			subtr_data[u] = x;
		}
		heapify(u);
		refresh(u);
		return u;
	}
	// O(1)
	int size(int u) const{
		return ~u ? internal_size[u] : 0;
	}
	// Assuming u lies in the subtree of root, find the position of u in the preorder traversal of subtree of root
	// O(log(n))
	int position(int root, int u){
		assert(0 <= root && 0 <= u && root < (int)pv.size() && u < (int)pv.size());
		int pos = size(left[u]);
		for(; ~pv[u]; u = pv[u]) if(left[pv[u]] != u) pos += size(left[pv[u]]) + 1;
		assert(root == u);
		return pos;
	}
	// Split to [-inf, x), [x, inf)
	// Data must be sorted by cmp
	// O(log(n))
	template<class Compare = less<>>
	pair<int, int> split_by_key(int root, const T &x, Compare cmp = less<>()){
		if(!~root) return {-1, -1};
		if(cmp(data[root], x)){
			auto [a, b] = split_by_key(right[root], x, cmp);
			right[root] = a, refresh(root);
			return {root, b};
		}
		else{
			auto [a, b] = split_by_key(left[root], x, cmp);
			left[root] = b, refresh(root);
			return {a, root};
		}
	}
	// Split into [0, pos), [pos, size(root))
	// O(log(n))
	pair<int, int> split_by_order(int root, int pos){
		if(!~root){
			assert(pos == 0);
			return {-1, -1};
		}
		if(size(left[root]) < pos){
			auto [a, b] = split_by_order(right[root], pos - size(left[root]) - 1);
			right[root] = a, refresh(root);
			return {root, b};
		}
		else{
			auto [a, b] = split_by_order(left[root], pos);
			left[root] = b, refresh(root);
			return {a, root};
		}
	}
	// Split to [True segment], [False segment]
	// Data must be sorted by pred
	// O(log(n))
	pair<int, int> split_by_pred(int root, auto pred){
		if(!~root) return {-1, -1};
		if(pred(root)){
			auto [a, b] = split_by_pred(right[root], pred);
			right[root] = a, refresh(root);
			return {root, b};
		}
		else{
			auto [a, b] = split_by_pred(left[root], pred);
			left[root] = b, refresh(root);
			return {a, root};
		}
	}
	// Split into [0, l), [l, r), [r, size(root))
	// O(log(n))
	array<int, 3> split_to_three(int root, int l, int r){
		assert(0 <= l && l <= r && r <= size(root));
		if(!~root) return {-1, -1, -1};
		int a, b, c;
		tie(a, b) = split_by_order(root, l);
		tie(b, c) = split_by_order(b, r - l);
		return {a, b, c};
	}
	// Split into [0, pos[0]), [pos[0], pos[1]), ..., [pos[size(pos) - 1], size(root))
	// O(size(pos) * log(n))
	vector<int> split(int root, vector<int> pos){
		assert(is_sorted(pos.begin(), pos.end()));
		if(pos.empty()) return {root};
		assert(0 <= pos.front() && pos.back() < size(root));
		if(!~root) return vector<int>((int)pos.size() + 1, -1);
		vector<int> res((int)pos.size() + 1);
		res[0] = root;
		for(auto i = 0, last = 0; i < (int)pos.size(); ++ i){
			tie(res[i], res[i + 1]) = split_by_order(res[i], pos[i] - last);
			last = pos[i];
		}
		return res;
	}
	// Append u and v
	// O(log(n))
	int append(int u, int v){
		if(!~u || !~v) return ~u ? u : v;
		if(priority[v] < priority[u]){
			right[u] = append(right[u], v), refresh(u);
			return u;
		}
		else{
			left[v] = append(u, left[v]), refresh(v);
			return v;
		}
	}
	// Append treaps in order
	// O((list length) * log(n))
	template<size_t k>
	int append(array<int, k> list){
		return accumulate(list.begin(), list.end(), -1, [&](int u, int v){ return append(u, v); });
	}
	// Data must be sorted by cmp
	// O(log(n))
	template<class Compare = less<>>
	int _insert_by_key(int root, int u, Compare cmp = less<>()){
		if(!~root) return u;
		if(priority[root] > priority[u]){
			if(cmp(data[root], data[u])) right[root] = _insert_by_key(right[root], u, cmp);
			else left[root] = _insert_by_key(left[root], u, cmp);
			refresh(root);
			return root;
		}
		auto [a, b] = split_by_key(root, data[u], cmp);
		left[u] = a, right[u] = b;
		refresh(u);
		return u;
	}
	// Data must be sorted by cmp
	// O(log(n))
	template<class Compare = less<>>
	int insert_by_key(int root, const T &x, Compare cmp = less<>()){
		return _insert_by_key(root, new_node(x), cmp);
	}
	// O(log(n))
	int _insert_by_order(int root, int u, int pos){
		if(!~root){
			assert(pos == 0);
			return u;
		}
		if(priority[root] > priority[u]){
			if(size(left[root]) < pos) right[root] = _insert_by_order(right[root], u, pos - size(left[root]) - 1);
			else left[root] = _insert_by_order(left[root], u, pos);
			refresh(root);
			return root;
		}
		auto [a, b] = split_by_order(root, pos);
		left[u] = a, right[u] = b;
		refresh(u);
		return u;
	}
	// O(log(n))
	int insert_by_order(int root, const T &x, int pos){
		return _insert_by_order(root, new_node(x), pos);
	}
	// Data must be sorted by pred
	// O(log(n))
	int _insert_by_pred(int root, int u, auto pred){
		if(!~root) return u;
		if(priority[root] > priority[u]){
			if(pred(data[root])) right[root] = _insert_by_pred(right[root], u, pred);
			else left[root] = _insert_by_pred(left[root], u, pred);
			refresh(root);
			return root;
		}
		auto [a, b] = split_by_pred(root, pred);
		left[u] = a, right[u] = b;
		refresh(u);
		return u;
	}
	// O(log(n))
	int insert_by_pred(int root, const T &x, auto pred){
		return _insert_by_pred(root, new_node(x), pred);
	}
	// Erase the smallest element >= x.
	// Return -2 when no such element exists
	// Data must be sorted by cmp
	// O(log(n))
	template<class Compare = less<>>
	int erase_by_key(int root, const T &x, Compare cmp = less<>()){
		if(!~root) return -2;
		if(cmp(data[root], x)){
			int u = erase_by_key(right[root], x, cmp);
			if(u == -2) return -2;
			right[root] = u;
		}
		else{
			int u = erase_by_key(left[root], x, cmp);
			if(u == -2){
				dead_node.push_back(root);
				return append(left[root], right[root]);
			}
			left[root] = u;
		}
		refresh(root);
		return root;
	}
	// O(log(n))
	int erase_by_order(int root, int pos){
		assert(~root);
		if(size(left[root]) == pos){
			dead_node.push_back(root);
			return append(left[root], right[root]);
		}
		if(size(left[root]) < pos) right[root] = erase_by_order(right[root], pos - size(left[root]) - 1);
		else left[root] = erase_by_order(left[root], pos);
		refresh(root);
		return root;
	}
	// Erase the smallest element x with !pred(x)
	// Return -2 when no such element exists
	// Data must be sorted by pred
	// O(log(n))
	int erase_by_pred(int root, auto pred){
		if(!~root) return -2;
		if(pred(data[root])){
			int u = erase_by_pred(right[root], pred);
			if(u == -2) return -2;
			right[root] = u;
		}
		else{
			int u = erase_by_pred(left[root], pred);
			if(u == -2){
				dead_node.push_back(root);
				return append(left[root], right[root]);
			}
			left[root] = u;
		}
		refresh(root);
		return root;
	}
	// Data must be sorted by cmp
	// O(min(size(u), size(v)) * log(size ratio))
	template<class Compare = less<>>
	int unite_by_key(int u, int v, Compare cmp = less<>()){
		if(!~u || !~v) return ~u ? u : v;
		if(priority[u] < priority[v]) swap(u, v);
		auto [a, b] = split_by_key(v, data[u], cmp);
		left[u] = unite_by_key(left[u], a, cmp);
		right[u] = unite_by_key(right[u], b, cmp);
		refresh(u);
		return u;
	}
	void traverse(int root, auto f){
		if(~root){
			traverse(left[root], f);
			f(root);
			traverse(right[root], f);
			refresh(root);
		}
	}
	int build(int n){
		return build(vector<T>(n, T_id));
	}
	int build(int n, T init){
		return build(vector<T>(n, init));
	}
	int build(const vector<T> &a){
		auto recurse = [&](auto self, int l, int r)->int{
			if(l == r) return -1;
			int m = l + (r - l >> 1);
			return new_node(a[m], self(self, l, m), self(self, m + 1, r));
		};
		return recurse(recurse, 0, (int)a.size());
	}
	// Data must be sorted by cmp
	// O(log(n))
	template<class Compare = less<>>
	int order_of_key(int root, const T &x, Compare cmp = less<>()){
		int res = 0;
		while(~root){
			if(cmp(data[root], x)){
				res += size(left[root]) + 1;
				root = right[root];
			}
			else root = left[root];
		}
		return res;
	}
	// Data must be sorted by pred
	// O(log(n))
	int partition_point(int root, auto pred){
		int res = 0;
		while(~root){
			if(pred(data[root])){
				res += size(left[root]) + 1;
				root = right[root];
			}
			else root = left[root];
		}
		return res;
	}
	// O(log(n))
	void set(int root, int p, const T &x){
		assert(0 <= p && p < size(root));
		int u = root;
		while(true){
			if(size(left[u]) == p){
				data[u] = x;
				refresh<false>(u);
				break;
			}
			if(size(left[u]) > p) u = left[u];
			else{
				p -= size(left[u]) + 1;
				u = right[u];
			}
		}
		while(u != root){
			u = pv[u];
			refresh<false>(u);
		}
	}
	// O(log(n))
	T query(int root, int p) const{
		assert(0 <= p && p < size(root));
		while(true){
			if(size(left[root]) == p) return data[root];
			if(size(left[root]) > p) root = left[root];
			else{
				p -= size(left[root]) + 1;
				root = right[root];
			}
		}
	}
	T _query(int root, int ql, int qr) const{
		if(!~root || qr <= 0 || size(root) <= ql) return T_id;
		if(ql <= 0 && size(root) <= qr) return subtr_data[root];
		T res = T_id;
		if(ql < size(left[root])) res = _query(left[root], ql, qr);
		if(ql <= size(left[root]) && size(left[root]) + 1 <= qr) res = TT(res, data[root]);
		if(size(left[root]) + 1 < qr) res = TT(res, _query(right[root], ql - size(left[root]) - 1, qr - size(left[root]) - 1));
		return res;
	}
	// O(log(n))
	T query(int root, int ql, int qr) const{
		assert(0 <= ql && ql <= qr && qr <= size(root));
		return ql == qr ? T_id : _query(root, ql, qr);
	}
	// pred(sum[ql, r)) is T, T, ..., T, F, F, ..., F
	// Returns max r with T
	// O(log(n))
	int max_pref(int root, int ql, auto pred) const{
		int n = size(root);
		assert(0 <= ql && ql <= n && pred(T_id));
		if(ql == n) return n;
		T sum = T_id;
		auto recurse = [&](auto self, int root, int l)->int{
			int r = l + size(root);
			if(!~root || r <= ql) return n;
			if(ql <= l && pred(TT(sum, subtr_data[root]))){
				sum = TT(sum, subtr_data[root]);
				return n;
			}
			if(auto p = self(self, left[root], l); p < n) return p;
			l += size(left[root]);
			return ql <= l && !pred(sum = TT(sum, data[root])) ? l : self(self, right[root], l + 1);
		};
		return recurse(recurse, root, 0);
	}
	// pred(sum[l, qr)) is F, F, ..., F, T, T, ..., T
	// Returns min l with T
	// O(log(n))
	int max_suff(int root, int qr, auto pred){
		int n = size(root);
		assert(0 <= qr && qr <= n && pred(T_id));
		if(qr == 0) return 0;
		T sum = T_id;
		auto recurse = [&](auto self, int root, int r)->int{
			int l = r - size(root);
			if(!~root || qr <= l) return 0;
			if(r <= qr && pred(TT(subtr_data[root], sum))){
				sum = TT(subtr_data[root], sum);
				return 0;
			}
			if(auto p = self(self, right[root], r); p > 0) return p;
			r -= size(right[root]);
			return r <= qr && !pred(sum = TT(data[root], sum)) ? r : self(self, left[root], r - 1);
		};
		return recurse(recurse, root, n);
	}
};
]]></content>
	<!-- Optional: Set a tabTrigger to define how to trigger the snippet -->
	<tabTrigger>treap_query</tabTrigger> -->
	<!-- Optional: Set a scope to limit where the snippet will trigger -->
	<scope>source.c++</scope> -->
</snippet>
