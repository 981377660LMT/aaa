<snippet>
	<content><![CDATA[
// For a commutative data structure supporting O(T(n)) update, support deletion of earliest update in O(T(n) * log(n)) online.
template<class E, class I, class T, class R>
struct query_queue{
	I insert;
	T time;
	R reverse_to;
	int zero_cnt = 0;
	vector<int> log;
	vector<pair<bool, E>> s;
	query_queue(I insert, T time, R reverse_to): insert(insert), time(time), reverse_to(reverse_to), log({time()}){ }
	void pop(){
		if(!zero_cnt){
			zero_cnt = (int)s.size();
			reverse(s.begin(), s.end());
			reverse_to(log[0]);
			log.resize(1);
			for(auto &p: s){
				p.first = false;
				insert(p.second);
				log.push_back(time());
			}
		}
		static array<vector<pair<bool, E>>, 2> cur;
		while(s.back().first){
			cur[1].push_back(s.back());
			s.pop_back();
		}
		for(auto size = zero_cnt & -zero_cnt, i = 0; i < size; ++ i){
			assert(!s.back().first);
			cur[0].push_back(s.back());
			s.pop_back();
		}
		reverse_to(log[s.size()]);
		log.resize(s.size() + 1);
		for(auto z: {1, 0}) for(; !cur[z].empty(); cur[z].pop_back()){
			insert(cur[z].back().second);
			log.push_back(time());
			s.push_back(cur[z].back());
		}
		assert(!s.back().first);
		s.pop_back();
		reverse_to(log[s.size()]);
		log.resize(s.size() + 1);
		-- zero_cnt;
	}
	void push(const E &e){
		s.push_back({true, e});
		insert(e);
	}
};
]]></content>
	<!-- Optional: Set a tabTrigger to define how to trigger the snippet -->
	<tabTrigger>query_queue</tabTrigger> -->
	<!-- Optional: Set a scope to limit where the snippet will trigger -->
	<scope>source.c++</scope> -->
</snippet>
