<snippet>
	<content><![CDATA[
// Requires persistent_segment_tree
template<int TYPE, class T, class Compare = less<>>
struct relative_query_solver_online{ // TYPE: {0: distinct value query, 1: less-than-k query}
	int n;
	Compare cmp;
	vector<int> pos;
	persistent_segment_tree<int, plus<>> ds;
	vector<T> cmpr;
	relative_query_solver_online(): ds(1, plus<>(), 0){ }
	relative_query_solver_online(const vector<T> &a, Compare cmp = less<>()): n((int)a.size()), pos(n + 1), ds(n, plus<>(), 0), cmp(cmp){
		vector<array<int, 2>> event(n);
		if(!TYPE){
			map<T, int, Compare> q(cmp);
			for(auto i = 0; i < n; ++ i){
				event[i] = {(q.count(a[i]) ? q[a[i]] : -1), i};
				q[a[i]] = i;
			}
		}
		else{
			cmpr = a;
			sort(cmpr.begin(), cmpr.end(), cmp), cmpr.erase(unique(cmpr.begin(), cmpr.end()), cmpr.end());
			for(auto i = 0; i < n; ++ i) event[i] = {std::lower_bound(cmpr.begin(), cmpr.end(), a[i], cmp) - cmpr.begin(), i};
		}
		sort(event.begin(), event.end(), greater<>());
		for(auto i = 0; i <= n; ++ i){
			while(!event.empty() && event.back()[0] < i){
				ds.set(ds.last_state(), event.back()[1], 1);
				event.pop_back();
			}
			pos[i] = ds.last_state();
		}
	}
	// Rescalling function for less-than-k query
	int lower_bound(T k){ // exclusive
		return std::lower_bound(cmpr.begin(), cmpr.end(), k, cmp) - cmpr.begin();
	}
	int upper_bound(T k){ // inclusive
		return std::upper_bound(cmpr.begin(), cmpr.end(), k, cmp) - cmpr.begin();
	}
	// For distinct value query
	int count_distinct(int ql, int qr){
		return assert(!TYPE), ds.query(pos[ql], ql, qr);
	}
	// For comparison query
	int count_less(int ql, int qr, T k){
		return assert(TYPE), ds.query(pos[lower_bound(k)], ql, qr);
	}
	int count_equal_or_less(int ql, int qr, T k){
		return assert(TYPE), ds.query(pos[upper_bound(k)], ql, qr);
	}
	int count_greater(int ql, int qr, T k){
		return assert(TYPE), qr - ql - ds.query(pos[upper_bound(k)], ql, qr);
	}
	int count_equal_or_greater(int ql, int qr, T k){
		return assert(TYPE), qr - ql - ds.query(pos[lower_bound(k)], ql, qr); 
	}
	int count_within(int ql, int qr, T kl, T kr){ // Count # of elements within [kl, kr)
		return assert(TYPE), ds.query(pos[lower_bound(kr)], ql, qr) - ds.query(pos[lower_bound(kl)], ql, qr);
	}
	// TODO: Finish binary search with petro camp problem
};
]]></content>
	<!-- Optional: Set a tabTrigger to define how to trigger the snippet -->
	<tabTrigger>relative_query_solver_online</tabTrigger> -->
	<!-- Optional: Set a scope to limit where the snippet will trigger -->
	<scope>source.c++</scope> -->
</snippet>
