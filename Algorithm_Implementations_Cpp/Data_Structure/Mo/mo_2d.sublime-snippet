<snippet>
	<content><![CDATA[
// Reorder N 2D points with max_x - min_x <= X, max_y - min_y <= Y
// so that sum(abs(xi - x(i+1)) + abs(yi - y(i+1)) is small
// and process queries on the new order.
// X * BX inc_x and dec_x calls, X * Y / BX inc_y and dec_y calls at max
// set BX = sqrt(X Y / N) to achieve sqrt(X Y N) calls at max
template<int BX>
struct mo_2d{
	vector<array<int, 3>> points; // x, y, ind
	void insert(int x, int y, int id){
		points.push_back({x, y, id});
	}
	// starting from (0, 0), access each points and execute queries
	void solve(auto inc_x, auto dec_x, auto inc_y, auto dec_y, auto process){
		auto cmp = [&](const auto &p, const auto &q)->bool{
			return p[0] / BX != q[0] / BX ? p < q : p[0] / BX & 1 ? p[1] < q[1] : p[1] > q[1];
		};
		sort(points.begin(), points.end(), cmp);
		int x = 0, y = 0;
		for(auto &[qx, qy, id]: points){
			while(qx < x) dec_x(), -- x;
			while(y < qy) inc_y(), ++ y;
			while(x < qx) inc_x(), ++ x;
			while(qy < y) dec_y(), -- y;
			process(id);
		}
	}
};
/*
int l = 0, r = 0;
	auto inc_x = [&]()->void{
		// erase a[l]

		++ l;
	};
	auto dec_x = [&]()->void{
		-- l;
		// insert a[l]

	};
	auto inc_y = [&]()->void{
		// insert a[r]

		++ r;
	};
	auto dec_y = [&]()->void{
		-- r;
		// erase a[r]

	};
	vector<int> res(qn);
	auto process = [&](int qi)->void{
		
	};
	mo.solve(inc_x, dec_x, inc_y, dec_y, process);
*/
]]></content>
	<!-- Optional: Set a tabTrigger to define how to trigger the snippet -->
	<tabTrigger>mo_2d</tabTrigger> -->
	<!-- Optional: Set a scope to limit where the snippet will trigger -->
	<scope>source.c++</scope> -->
</snippet>
