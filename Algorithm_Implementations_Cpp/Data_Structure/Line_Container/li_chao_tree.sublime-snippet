<snippet>
	<content><![CDATA[
// Data structure maintaining functions [th_low, th_high]->X such that
// any two functions f and g are either equal or has a point p \in [th_low, th_high] satisfying either
// (f(x) < g(x) for all x<p, f(p) = g(p), and f(y) > g(y) for all p<=y) or
// (f(x) > g(x) for all x<p, f(p) = g(p), and f(y) < g(y) for all p<=y).
template<class T, class X, class F, class Compare = less<>>
struct li_chao_tree{
	vector<array<int, 2>> child{{-1, -1}};
	X minf;
	vector<int> data{-1}; // -1 denotes the function at -inf.
	F evaluate; // evaluate(i, p): value of function i at p
	T th_low, th_high;
	Compare cmp;
	li_chao_tree(T th_low, T th_high, F evaluate, X _type_deducer, Compare cmp = less<>(), X minf = numeric_limits<X>::min()): th_low(th_low), th_high(th_high), evaluate(evaluate), cmp(cmp), minf(minf){ }
	// function i is equal or higher than j on [l, r]
	bool majorize(int i, int j, T l, T r) const{
		if(!~j) return true;
		if(!~i) return false;
		return !cmp(evaluate(i, l), evaluate(j, l)) && !cmp(evaluate(i, r), evaluate(j, r));
	}
	// Insert the function i.
	// O(log(n))
	void insert(int i){
		assert(i >= 0);
		int u = 0;
		T l = th_low, r = th_high;
		while(true){
			if(majorize(i, data[u], l, r)) swap(i, data[u]);
			if(majorize(data[u], i, l, r)) break;
			if(cmp(evaluate(data[u], l), evaluate(i, l))) swap(i, data[u]);
			T m = l + r >> 1;
			if(cmp(evaluate(data[u], m), evaluate(i, m))){
				swap(i, data[u]);
				if(!~child[u][0]){
					child[u][0] = (int)child.size();
					child.push_back({-1, -1});
					data.push_back(-1);
				}
				u = child[u][0];
				r = m;
			}
			else{
				if(!~child[u][1]){
					child[u][1] = (int)child.size();
					child.push_back({-1, -1});
					data.push_back(-1);
				}
				u = child[u][1];
				l = m;
			}
		}
	}
	// Return the pair {evaluate(i, p), i} where i achieves the maximum evaluation at p among all other functions in the data structure.
	// O(log(n))
	pair<X, int> query_max(T p) const{
		assert(th_low <= p && p <= th_high);
		if(!~data[0]) return {minf, -1};
		X optv = minf;
		int opti = -1, u = 0;
		T l = th_low, r = th_high;
		while(true){
			if(X cv = evaluate(data[u], p); cv > optv){
				optv = cv;
				opti = data[u];
			}
			T m = (l + r) / 2;
			if(p < m){
				if(!~child[u][0]) break;
				u = child[u][0];
				r = m;
			}
			else{
				if(!~child[u][1]) break;
				u = child[u][1];
				l = m;
			}
		}
		return {optv, opti};
	}
};
]]></content>
	<!-- Optional: Set a tabTrigger to define how to trigger the snippet -->
	<tabTrigger>li_chao_tree</tabTrigger> -->
	<!-- Optional: Set a scope to limit where the snippet will trigger -->
	<scope>source.c++</scope> -->
</snippet>
