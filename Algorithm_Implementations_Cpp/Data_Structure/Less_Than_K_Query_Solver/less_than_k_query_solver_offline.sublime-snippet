<snippet>
	<content><![CDATA[
// Requires fenwick_tree_sum
template<class T>
struct less_than_k_query_solver_offline{
	int n, sigma;
	vector<tuple<int, int, T>> event;
	vector<array<int, 4>> queries;
	less_than_k_query_solver_offline(const vector<int> &a, int sigma): less_than_k_query_solver_offline(a, sigma, vector<T>(sigma, 1)){ }
	less_than_k_query_solver_offline(const vector<int> &a, int sigma, const vector<T> &w): n((int)a.size()), sigma(sigma), event(n){
		for(auto &x: a) assert(0 <= x && x < sigma);
		assert(n == (int)w.size());
		for(auto i = 0; i < n; ++ i) event[i] = {a[i], i, w[i]};
	}
	less_than_k_query_solver_offline &operator=(const less_than_k_query_solver_offline &ltk){
		n = ltk.n;
		sigma = ltk.sigma;
		event = ltk.event;
		queries = ltk.queries;
		return *this;
	}
	// Set the answer of query qi to the sum of w[i] over all i with ql <= i < qr and i < k
	void query(int qi, int ql, int qr, int k){
		queries.push_back({k, ql, qr, qi});
	}
	// f(query id, answer)
	// O((n + q) * (log(n) + log(q)))
	void solve(auto f){
		sort(queries.begin(), queries.end());
		sort(event.rbegin(), event.rend());
		fenwick_tree_sum<T> tr(n);
		for(auto &q: queries){
			while(!event.empty() && get<0>(event.back()) < q[0]){
				tr.update(get<1>(event.back()), get<2>(event.back()));
				event.pop_back();
			}
			f(q[3], tr.query(q[1], q[2]));
		}
	}
};
]]></content>
	<!-- Optional: Set a tabTrigger to define how to trigger the snippet -->
	<tabTrigger>less_than_k_query_solver_offline</tabTrigger> -->
	<!-- Optional: Set a scope to limit where the snippet will trigger -->
	<scope>source.c++</scope> -->
</snippet>
