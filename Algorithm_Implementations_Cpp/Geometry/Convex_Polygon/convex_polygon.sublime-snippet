<snippet>
	<content><![CDATA[
// Requires point
template<class T>
struct convex_polygon{
	// {lower part, upper part}
	array<vector<point<T>>, 2> data;
	// Construct the convex polygon as the convex hull of arr
	// O(n * log(n)) if is_sorted = false, O(n) otherwise
	convex_polygon(vector<point<T>> arr = {}, bool is_sorted = false){
		if(!is_sorted) sort(arr.begin(), arr.end()), arr.erase(unique(arr.begin(), arr.end()), arr.end());;
#define ADDP(C, cmp) while((int)C.size() > 1 && doubled_signed_area(C[(int)C.size() - 2], p, C.back()) cmp 0) C.pop_back(); C.push_back(p);
		for(auto &p: arr){
			ADDP(data[0], >=)
			ADDP(data[1], <=)
		}
#undef ADDP
		reverse(data[1].begin(), data[1].end());
	}
	// O(n)
	vector<point<T>> raw_data() const{
		if((int)data[0].size() <= 1) return data[0];
		vector<point<T>> res(data[0]);
		res.insert(res.end(), ++ data[1].begin(), -- data[1].end());
		return res;
	}
	// O(1)
	point<T> &at(pair<bool, int> i){
		return data[i.first][i.second];
	}
	// O(1)
	const point<T> &at(pair<bool, int> i) const{
		return data[i.first][i.second];
	}
	// Returns the sorted list of points
	// O(n)
	vector<point<T>> linearize() const{
		if((int)data[0].size() <= 1) return data[0];
		vector<point<T>> res((int)data[0].size() + (int)data[1].size() - 2);
		merge(data[0].begin(), data[0].end(), ++ data[1].rbegin(), -- data[1].rend(), res.begin());
		return res;
	}
	// Merge two convex polygons
	// O(n + m)
	convex_polygon operator^(const convex_polygon &otr) const{
		vector<point<T>> A = linearize(), B = otr.linearize(), C(A.size() + B.size());
		merge(A.begin(), A.end(), B.begin(), B.end(), C.begin());
		return {C, true};
	}
	// O(n)
	array<vector<point<T>>, 2> boundary() const{
		vector<point<T>> L(data[0]), R(data[1]);
		for(auto i = (int)data[0].size() - 1; i > 0; -- i) L[i] -= L[i - 1];
		for(auto i = (int)data[1].size() - 1; i > 0; -- i) R[i] -= R[i - 1];
		return {L, R};
	}
	// Minkowski addition
	// O(n + m)
	convex_polygon operator+(const convex_polygon &otr) const{
		convex_polygon res;
		auto A = boundary(), B = otr.boundary();
		for(auto t = 0; t < 2; ++ t){
			if(A[t].empty() || B[t].empty()) continue;
			res.data[t].resize(A[t].size() + B[t].size() - 1);
			res.data[t][0] = A[t][0] + B[t][0];
			merge(A[t].begin() + 1, A[t].end(), B[t].begin() + 1, B[t].end(), res.data[t].begin() + 1, [&](auto p, auto q){ return (p ^ q) > 0; });
			for(auto i = 1; i < (int)res.data[t].size(); ++ i) res.data[t][i] += res.data[t][i - 1];
		}
		return res;
	}
	// O(n)
	convex_polygon operator-() const{
		auto A = linearize();
		for(auto &p: A) p = -p;
		reverse(A.begin(), A.end());
		return {A, true};
	}
	// O(n)
	convex_polygon operator-(const convex_polygon &otr) const{
		return *this + -otr;
	}
	// Returns the point with the maximum inner product with p
	// Assumes the polygon is not empty
	// O(log(n))
	pair<bool, int> extreme_point(const point<T> &p) const{
		assert(!data[0].empty() && !data[1].empty());
		auto &c = data[p.y >= 0];
		int low = 0, high = (int)c.size();
		while(high - low >= 3){
				int mid = low + (high - low >> 1);
				p * c[mid] <= p * c[mid + 1] ? low = mid : high = mid + 1;
		}
		int res = low;
		for(auto i = low + 1; i < high; ++ i) if(p * c[res] < p * c[i]) res = i;
		return {p.y >= 0, res};
	}
	// Assumes the convex polygon is not empty
	// O(n)
	array<pair<bool, int>, 2> diameter() const{
		assert(!data[0].empty() && !data[1].empty());
		if((int)data[0].size() == 1) return {{{0, 0}, {0, 0}}};
		pair<T, array<pair<bool, int>, 2>> res{0, {{{0, 0}, {0, 0}}}};
		auto next = [&](pair<bool, int> i)->pair<bool, int>{
			++ i.second;
			if(i.second == (int)data[i.first].size()) i.first = !i.first, i.second = 1;
			return i;
		};
		pair<bool, int> i, j = {0, 1}, ni, nj = next(j);
		for(auto t = 0; t < 2; ++ t) for(auto x = 0; x < (int)data[t].size() - 1; ++ x){
			i = {t, x}, ni = next(i);
			for(; ; j = nj, nj = next(j)){
				res = max(res, decltype(res){squared_distance(at(i), at(j)), {i, j}});
				if((at(ni) - at(i) ^ at(nj) - at(j)) <= 0) break;
			}
		}
		return res.second;
	}
	// Partition the plane into three parts: 0(strictly inside), 1(boundary), 2(strictly outside)
	// Returns the part the point belongs to
	// O(log(n))
	int locate(const point<T> &p) const{
		if(data[0].empty()) return 2;
		auto lies_on = [&](const point<T> &a, const point<T> &b)->bool{
			auto d = b - a;
			if(d ^ p - a) return false;
			auto x = d * (p - a);
			return 0 <= x && x <= d.squared_norm();
		};
		if((int)data[0].size() == 2 && (int)data[1].size() == 2) return 1 + !lies_on(data[0].front(), data[0].back());
		auto last = data[1][(int)data.size() - 2];
		if(clockwise(data[0][0], data[0][1], p) || clockwise(last, data[0][0], p)) return 2;
		if(lies_on(data[0][0], data[0][1]) || lies_on(last, data[0][0])) return 1;
		int l = 1, r = (int)data[0].size() + (int)data[1].size() - 2;
		while(r - l >= 2){
			int m = l + (r - l >> 1);
			counterclockwise(data[0][0], m < (int)data[0].size() - 1 ? data[0][m] : data[1][m - (int)data[0].size() + 1], p) ? l = m : r = m;
		}
		auto a = l < (int)data[0].size() - 1 ? data[0][l] : data[1][l - (int)data[0].size() + 1];
		auto b = l + 1 < (int)data[0].size() - 1 ? data[0][l + 1] : data[1][l + 1 - (int)data[0].size() + 1];
		if(lies_on(a, b)) return 1;
		else if(counterclockwise(a, b, p)) return 0;
		else return 2;
	}
};
]]></content>
	<!-- Optional: Set a tabTrigger to define how to trigger the snippet -->
	<tabTrigger>convex_polygon</tabTrigger> -->
	<!-- Optional: Set a scope to limit where the snippet will trigger -->
	<scope>source.c++</scope> -->
</snippet>
