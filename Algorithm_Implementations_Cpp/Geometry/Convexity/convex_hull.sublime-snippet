<snippet>
	<content><![CDATA[
// Type {0: both, 1: lower, 2: upper}
// Requires point
template<class T, int type = 0>
struct convex_hull{
	vector<point<T>> lower, upper;
	convex_hull(vector<point<T>> arr = {}, bool is_sorted = false){
		if(!is_sorted) sort(arr.begin(), arr.end()), arr.erase(unique(arr.begin(), arr.end()), arr.end());;
#define ADDP(C, cmp) while((int)C.size() > 1 && doubled_signed_area(C[(int)C.size() - 2], p, C.back()) cmp 0) C.pop_back(); C.push_back(p);
		for(auto &p: arr){
			if(type < 2){ ADDP(lower, >=) }
			if(!(type & 1)){ ADDP(upper, <=) }
		}
#undef ADDP
		reverse(upper.begin(), upper.end());
	}
	vector<point<T>> get_hull() const{
		if(type) return type == 1 ? lower : upper;
		if((int)lower.size() <= 1) return lower;
		vector<point<T>> res(lower);
		res.insert(res.end(), ++ upper.begin(), -- upper.end());
		return res;
	}
	// Returns the point in convex hull with the maximum inner product with p
	// O(log(n))
	pair<bool, int> max_element(const point<T> &p) const{
		if(p.y >= 0 && !upper.empty()){
			int low = 0, high = (int)upper.size();
			while(high - low >= 3){
				int mid = low + (high - low >> 1);
				p * upper[mid] <= p * upper[mid + 1] ? low = mid : high = mid + 1;
			}
			int res = low;
			for(auto i = low + 1; i < high; ++ i) if(p * upper[res] < p * upper[i]) res = i;
			return {1, res};
		}
		else{
			assert(!lower.empty());
			int low = 0, high = (int)lower.size();
			while(high - low >= 3){
				int mid = low + (high - low >> 1);
				p * lower[mid] >= p * lower[mid + 1] ? low = mid : high = mid + 1;
			}
			int res = low;
			for(auto i = low + 1; i < high; i ++) if(p * lower[res] > p * lower[i]) res = i;
			return {0, res};
		}
	}
	// Returns the sorted list of points
	// O(n)
	vector<point<T>> linearize() const{
		if(type == 1) return lower;
		if(type == 2){ vector<point<T>> res(upper); reverse(res.begin(), res.end()); return res; }
		if((int)lower.size() <= 1) return lower;
		vector<point<T>> res((int)lower.size() + (int)upper.size() - 2);
		merge(lower.begin(), lower.end(), ++ upper.rbegin(), -- upper.rend(), res.begin());
		return res;
	}
	// Merge two convex hulls
	// O(n + m)
	convex_hull operator^(const convex_hull &otr) const{
		vector<point<T>> A = linearize(), B = otr.linearize(), C((int)A.size() + (int)B.size());
		merge(A.begin(), A.end(), B.begin(), B.end(), C.begin());
		return {C, true};
	}
	pair<vector<point<T>>, vector<point<T>>> get_boundary() const{
		vector<point<T>> L(lower), R(upper);
		for(auto i = (int)lower.size() - 1; i > 0; -- i) L[i] -= L[i - 1];
		for(auto i = (int)upper.size() - 1; i > 0; -- i) R[i] -= R[i - 1];
		return {L, R};
	}
	// Minkowski addition
	// O(n + m)
	convex_hull operator+(const convex_hull &otr) const{
		convex_hull res;
		auto A = get_boundary(), B = otr.get_boundary();
#define PROCESS(COND, X, Y) \
if(COND && !A.X.empty() && !B.X.empty()){ \
	res.Y.resize((int)A.X.size() + (int)B.X.size() - 1); \
	res.Y[0] = A.X.front() + B.X.front(); \
	merge(A.X.begin() + 1, A.X.end(), B.X.begin() + 1, B.X.end(), res.Y.begin() + 1, [&](auto p, auto q){ return (p ^ q) > 0; }); \
	for(auto i = 1; i < (int)res.Y.size(); ++ i) res.Y[i] += res.Y[i - 1]; \
}
		PROCESS(type < 2, first, lower)
		PROCESS(!(type & 1), second, upper)
#undef PROCESS
		return res;
	}
	convex_hull operator-() const{
		auto A = linearize();
		for(auto &p: A) p = -p;
		reverse(A.begin(), A.end());
		return {A, true};
	}
	convex_hull operator-(const convex_hull &otr) const{
		return *this + -otr;
	}
};
]]></content>
	<!-- Optional: Set a tabTrigger to define how to trigger the snippet -->
	<tabTrigger>convex_hull</tabTrigger> -->
	<!-- Optional: Set a scope to limit where the snippet will trigger -->
	<scope>source.c++</scope> -->
</snippet>
