<snippet>
	<content><![CDATA[
// T must be able to hold up to max(abs(x), abs(y), abs(r))^2
// Requires point
template<class T>
struct circle{
	point<T> center;
	T radius;
	friend istream &operator>>(istream &in, circle &c){
		return in >> c.center >> c.radius;
	}
	template<class U>
	U square(U x){
		return x * x;
	}
	bool contains(const point<T> &p) const{
		return squared_distance(center, p) <= square(radius);
	}
	bool strictly_contains(const point<T> &p) const{
		return squared_distance(center, p) < square(radius);
	}
	bool contains(const circle &c) const{
		return c.radius <= radius && squared_distance(center, c.center) <= square(radius - c.radius);
	}
	bool strictly_contains(const circle &c) const{
		return c.radius < radius && squared_distance(center, c.center) < square(radius - c.radius);
	}
	bool intersect(const circle &c) const{
		return square(radius - c.radius) <= squared_distance(center, c.center) && squared_distance(center, c.center) <= square(radius + c.radius);
	}
	bool intersect_at_one_point(const circle &c) const{
		return square(radius - c.radius) == squared_distance(center, c.center) || squared_distance(center, c.center) == square(radius + c.radius);
	}
	bool intersect_at_two_points(const circle &c) const{
		return square(radius - c.radius) < squared_distance(center, c.center) && squared_distance(center, c.center) < square(radius + c.radius);
	}
	// Returns the list of intersection points.
	// The ordering "center -> list" forms a positive orientation
	template<class U>
	vector<point<U>> intersections(const circle &c) const{
		if(!intersect(c)) return {};
		U dist = squared_distance(center, c.center);
		U A = (square(radius) - square(c.radius)) / (2 * dist);
		U B = (U)0.5 * sqrt((U)2 * (square(radius) + square(c.radius)) / dist - square<U>(square(radius) - square(c.radius)) / square(dist) - 1);
		return {
			{(U)0.5 * (center.x + c.center.x) + A * (c.center.x - center.x) + B * (c.center.y - center.y), (U)0.5 * (center.y + c.center.y) + A * (c.center.y - center.y) + B * (center.x - c.center.x)},
			{(U)0.5 * (center.x + c.center.x) + A * (c.center.x - center.x) - B * (c.center.y - center.y), (U)0.5 * (center.y + c.center.y) + A * (c.center.y - center.y) - B * (center.x - c.center.x)}
		};
	}
};
]]></content>
	<!-- Optional: Set a tabTrigger to define how to trigger the snippet -->
	<tabTrigger>circle</tabTrigger> -->
	<!-- Optional: Set a scope to limit where the snippet will trigger -->
	<scope>source.c++</scope> -->
</snippet>
