<snippet>
	<content><![CDATA[
// ---------------------------------------------
// | # of member function calls where          |
// | R is the size of the answer and           |
// | N is the size of the ground set           |
// ---------------------------------------------
// | Member Function | M1         | M2         |
// ---------------------------------------------
// | insert()        | O(R^3)     | O(R^2 * N) |
// | check()         | O(R^2 * N) | O(R^2 * N) |
// | clear()         | O(R^2)     | O(R * N)   |
// ---------------------------------------------
//
// Requires matroid
template<class M1, class M2>
vector<int> maximum_common_independent_set(int n, M1 m1, M2 m2){
	vector<bool> flag(n);
	for(auto u = 0; u < n; ++ u) if(m1.check(u) && m2.check(u)) flag[u] = true, m1.insert(u), m2.insert(u);
	auto augment = [&]()->bool{
		vector<int> pv(n, -1);
		queue<int> q({n}); // starts at dummy node
		auto forward_edge = [&](int x){
			vector<int> res;
			m1.clear();
			for(auto u = 0; u < n; ++ u) if(flag[u] && u != x) m1.insert(u);
			for(auto u = 0; u < n; ++ u) if(!flag[u] && !~pv[u] && m1.check(u)) res.push_back(u), pv[u] = x;
			return res;
		};
		auto backward_edge = [&](int x){
			m2.clear();
			for(auto rep = 0; rep < 2; ++ rep) for(auto u = 0; u < n; ++ u) if((u == x || flag[u]) && (pv[u] == -1) == rep){
				if(!m2.check(u)) return rep ? q.push(u), pv[u] = x, u : -1;
				m2.insert(u);
			}
			return n;
		};
		while(!q.empty()){
			int u = q.front(), v; q.pop();
			for(auto w: forward_edge(u)) while((v = backward_edge(w)) >= 0) if(v == n){
				while(w != n) flag[w].flip(), w = pv[w];
				return true;
			}
		}
		return false;
	};
	while(augment());
	vector<int> res;
	for(auto i = 0; i < n; ++ i) if(flag[i]) res.push_back(i);
	return res;
}
]]></content>
	<!-- Optional: Set a tabTrigger to define how to trigger the snippet -->
	<tabTrigger>maximum_common_independent_set</tabTrigger> -->
	<!-- Optional: Set a scope to limit where the snippet will trigger -->
	<scope>source.c++</scope> -->
</snippet>
