<snippet>
	<content><![CDATA[
struct fast_fourier_transform_wrapper{
	using CD = complex<double>;
	using CLD = complex<long double>;
	vector<CD> power{1, 1};
	vector<CLD> power_ld{1, 1};
	void adjust_power(int n){
		for(auto k = (int)power.size(); k < n; k <<= 1){
			power.resize(n), power_ld.resize(n);
			auto theta = polar(1.0L, acos(-1.0L) / k);
			for(auto i = k; i < k << 1; ++ i) power[i] = power_ld[i] = i & 1 ? power_ld[i >> 1] * theta : power_ld[i >> 1];
		}
	}
	// O(n log n)
	void transform(vector<CD> &p, bool invert = false){
		int n = (int)p.size();
		assert(n && __builtin_popcount(n) == 1);
		for(auto i = 1, j = 0; i < n; ++ i){
			int bit = n >> 1;
			for(; j & bit; bit >>= 1) j ^= bit;
			j ^= bit;
			if(i < j) swap(p[i], p[j]);
		}
		adjust_power(n);
		for(auto len = 1; len < n; len <<= 1) for(auto i = 0; i < n; i += len << 1) for(auto j = 0; j < len; ++ j){
			auto x = (double *)&power[j + len], y = (double *)&p[i + j + len];
			CD z(x[0] * y[0] - x[1] * y[1], x[0] * y[1] + x[1] * y[0]);
			p[len + i + j] = p[i + j] - z, p[i + j] += z;
		}
		if(invert){
			reverse(p.begin() + 1, p.end());
			auto inv_n = 1.0l / n;
			for(auto &x: p) x *= inv_n;
		}
	}
	vector<CD> buffer1, buffer2;
	template<class T>
	vector<T> convolute_naive(const vector<T> &p, const vector<T> &q){
		vector<T> res(max((int)p.size() + (int)q.size() - 1, 0));
		for(auto i = 0; i < (int)p.size(); ++ i) for(auto j = 0; j < (int)q.size(); ++ j) res[i + j] += p[i] * q[j];
		return res;
	}
	// Safe for sum(p[i]^2 + q[i]^2) lg2(n) < 9e14
	// O(n log n)
	template<class T>
	vector<T> convolute(const vector<T> &p, const vector<T> &q){
		if(min(p.size(), q.size()) < 60) return convolute_naive(p, q);
		int n = 1 << __lg((int)p.size() + (int)q.size() - 1) + 1;
		buffer1.assign(n, 0);
		for(auto i = 0; i < (int)p.size(); ++ i) buffer1[i].real(p[i]);
		for(auto i = 0; i < (int)q.size(); ++ i) buffer1[i].imag(q[i]);
		transform(buffer1);
		for(auto &x: buffer1) x *= x;
		buffer2.assign(n, 0);
		for(auto i = 0; i < n; ++ i) buffer2[i] = buffer1[i] - conj(buffer1[-i & n - 1]);
		transform(buffer2, true);
		vector<T> res((int)p.size() + (int)q.size() - 1);
		for(auto i = 0; i < (int)res.size(); ++ i) res[i] = llround(buffer2[i].imag() / 4);
		return res;
	}
	// Safe for 64-bit integer range
	// O(n log n)
	template<class T>
	vector<T> convolute_splitting(const vector<T> &p, const vector<T> &q){
		if(min(p.size(), q.size()) < 80) return convolute_naive(p, q);
		int n = 1 << __lg((int)p.size() + (int)q.size() - 1) + 1;
		const int cut = 32000;
		buffer1.assign(n, 0);
		for(auto i = 0; i < (int)p.size(); ++ i) buffer1[i] = {(long long)p[i] / cut, (long long)p[i] % cut};
		transform(buffer1);
		buffer2.assign(n, 0);
		for(auto i = 0; i < (int)q.size(); ++ i) buffer2[i] = {(long long)q[i] / cut, (long long)q[i] % cut};
		transform(buffer2);
		for(auto i = 0; i <= n >> 1; ++ i){
			int j = -i & n - 1;
			if(i == j){
				tie(buffer1[i], buffer2[i]) = pair<CD, CD>{
					(buffer1[i] + conj(buffer1[i])) * buffer2[i] / 2.0,
					(buffer1[i] - conj(buffer1[i])) * buffer2[i] / 2i
				};
			}
			else{
				tie(buffer1[i], buffer2[i], buffer1[j], buffer2[j]) = tuple<CD, CD, CD, CD>{
					(buffer1[i] + conj(buffer1[j])) * buffer2[i] / 2.0,
					(buffer1[i] - conj(buffer1[j])) * buffer2[i] / 2i,
					(buffer1[j] + conj(buffer1[i])) * buffer2[j] / 2.0,
					(buffer1[j] - conj(buffer1[i])) * buffer2[j] / 2i
				};
			}
		}
		transform(buffer1, true);
		transform(buffer2, true);
		vector<T> res((int)p.size() + (int)q.size() - 1);
		for(auto i = 0; i < (int)res.size(); ++ i) res[i] = ((T)llround(buffer1[i].real()) * cut + (T)(llround(buffer1[i].imag()) + llround(buffer2[i].real()))) * cut + (T)llround(buffer2[i].imag());
		return res;
	}
};

fast_fourier_transform_wrapper FFT;
]]></content>
	<!-- Optional: Set a tabTrigger to define how to trigger the snippet -->
	<tabTrigger>fast_fourier_transform</tabTrigger> -->
	<!-- Optional: Set a scope to limit where the snippet will trigger -->
	<scope>source.c++</scope> -->
</snippet>
