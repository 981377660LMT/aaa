<snippet>
	<content><![CDATA[
// T must be of modular type
// mod must be a prime
// Requires modular
template<class T>
struct number_theoric_transform_wrapper{
	T primitive_root = {};
	vector<T> power = {1, 1};
	number_theoric_transform_wrapper(){
		if(primitive_root) return;
		typename T::Type mod = T::mod();
		if(mod == 2){
			primitive_root = 1;
			return;
		}
		if(mod == 998244353){
			primitive_root = 3;
			return;
		}
		typename T::Type divs[20] = {};
		divs[0] = 2;
		typename T::Type x = (mod - 1) / 2;
		while(~x & 1) x >>= 1;
		int cnt = 1;
		for(auto i = 3; 1LL * i * i <= x; i += 2) if(x % i == 0){
			divs[cnt ++] = i;
			while(x % i == 0) x /= i;
		}
		if(x > 1) divs[cnt ++] = x;
		for(auto g = 2; ; ++ g){
			bool ok = true;
			for(auto i = 0; i < cnt; ++ i){
				unsigned long long r = 1;
				if(mod == 1) r = 0;
				else{
					unsigned long long y = (mod - 1) / divs[i] % mod;
					if(y < 0) y += mod;
					for(; g; y = y * y % mod, g >>= 1) if(g & 1) r = (r * y) % mod;
				}
				if(r == 1){
					ok = false;
					break;
				}
			}
			if(ok){
				primitive_root = g;
				return;
			}
		}
		assert(false);
	}
	void adjust_power(int n){
		for(auto k = (int)power.size(); k < n; k <<= 1){
			power.resize(n, 1);
			T w = primitive_root ^ (T::mod() - 1) / (k << 1);
			for(auto i = k; i < k << 1; ++ i) power[i] = i & 1 ? power[i >> 1] * w : power[i >> 1];
		}
	}
	// n must be a power of two
	// O(n log n)
	void transform(vector<T> &p, bool invert = false){
		int n = (int)p.size();
		assert(n && __builtin_popcount(n) == 1 && (T::mod() - 1) % n == 0);
		for(auto i = 1, j = 0; i < n; ++ i){
		int bit = n >> 1;
			for(; j & bit; bit >>= 1) j ^= bit;
			j ^= bit;
			if(i < j) swap(p[i], p[j]);
		}
		adjust_power(n);
		for(auto len = 1; len < n; len <<= 1) for(auto i = 0; i < n; i += len << 1) for(auto j = 0; j < len; ++ j){
			T x = p[i + j], y = p[len + i + j] * power[len + j];
			p[i + j] = x + y, p[len + i + j] = x - y;
		}
		if(invert){
			reverse(p.begin() + 1, p.end());
			T inv_n = T(1) / n;
			for(auto &x: p) x *= inv_n;
		}
	}
	vector<T> buffer1, buffer2;
	// Double the length of the NTT array
	// n must be a power of two
	// O(n log n)
	void double_up(vector<T> &p){
		int n = (int)p.size();
		assert(n && __builtin_popcount(n) == 1 && (T().mod() - 1) % (n << 1) == 0);
		buffer1.resize(n << 1);
		for(auto i = 0; i < n; ++ i) buffer1[i << 1] = p[i];
		transform(p, true);
		adjust_power(n << 1);
		for(auto i = 0; i < n; ++ i) p[i] *= power[n | i];
		transform(p);
		for(auto i = 0; i < n; ++ i) buffer1[i << 1 | 1] = p[i];
		p = buffer1;
	}
	vector<T> convolute_naive(const vector<T> &p, const vector<T> &q){
		vector<T> res(max((int)p.size() + (int)q.size() - 1, 0));
		for(auto i = 0; i < (int)p.size(); ++ i) for(auto j = 0; j < (int)q.size(); ++ j) res[i + j] += p[i] * q[j];
		return res;
	}
	// O((n + m) * log(n + m))
	vector<T> convolute(const vector<T> &p, const vector<T> &q){
		if(min(p.size(), q.size()) < 55) return convolute_naive(p, q);
		int m = (int)p.size() + (int)q.size() - 1, n = 1 << __lg(m) + 1;
		buffer1.assign(n, 0);
		copy(p.begin(), p.end(), buffer1.begin());
		transform(buffer1);
		buffer2.assign(n, 0);
		copy(q.begin(), q.end(), buffer2.begin());
		transform(buffer2);
		for(auto i = 0; i < n; ++ i) buffer1[i] *= buffer2[i];
		transform(buffer1, true);
		return vector<T>(buffer1.begin(), buffer1.begin() + m);
	}
	// O(n log n)
	vector<T> square(const vector<T> &p){
		if(p.size() < 40) return convolute_naive(p, p);
		int m = (int)p.size() * 2 - 1, n = 1 << __lg(m) + 1;
		buffer1.assign(n, 0);
		copy(p.begin(), p.end(), buffer1.begin());
		transform(buffer1);
		for(auto i = 0; i < n; ++ i) buffer1[i] *= buffer1[i];
		transform(buffer1, true);
		return vector<T>(buffer1.begin(), buffer1.begin() + m);
	}
};

number_theoric_transform_wrapper<modular> NTT;
]]></content>
	<!-- Optional: Set a tabTrigger to define how to trigger the snippet -->
	<tabTrigger>number_theoric_transform</tabTrigger> -->
	<!-- Optional: Set a scope to limit where the snippet will trigger -->
	<scope>source.c++</scope> -->
</snippet>
