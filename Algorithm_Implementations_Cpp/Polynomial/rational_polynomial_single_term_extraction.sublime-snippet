<snippet>
	<content><![CDATA[
// Returns [X^i]p(X)/q(X)
// T must be of modular type
// deg(p) < deg(q) must hold
// Requires modular, number_theoric_transform, and double_up_ntt
template<class T, class U, int primitive_root = 3>
T rational_polynomial_single_term_extraction(vector<T> p, vector<T> q, U i){
	assert(!q.empty() && q[0] != 0);
	int n = 1 << __lg((int)size(q) << 1 | 1) + 1;
	assert(i >= 0 && size(p) < size(q) && (T().mod() - 1) % n == 0);
	p.resize(n), q.resize(n);
	number_theoric_transform<T, primitive_root>(p);
	number_theoric_transform<T, primitive_root>(q);
	T inv2 = (T().mod() + 1) / 2;
	for(T w = 1 / T(primitive_root) ^ (T().mod() - 1) / n; i; i >>= 1){
		for(auto i = 0; i < n; ++ i) p[i] *= q[i < n / 2 ? i + n / 2 : i - n / 2];
		if(~i & 1){
			for(auto i = 0; i < n / 2; ++ i) p[i] = inv2 * (p[i] + p[i + n / 2]);
		}
		else{
			T pw = inv2;
			for(auto i = 0; i < n / 2; ++ i, pw *= w) p[i] = pw * (p[i] - p[i + n / 2]);
		}
		p.resize(n / 2);
		double_up_ntt<T, primitive_root>(p);
		q.resize(n / 2);
		for(auto i = 0; i < n / 2; ++ i) q[i] *= q[i + n / 2];
		double_up_ntt<T, primitive_root>(q);
	}
	return accumulate(begin(p), end(p), T(0)) / accumulate(begin(q), end(q), T(0));
}
]]></content>
	<!-- Optional: Set a tabTrigger to define how to trigger the snippet -->
	<tabTrigger>rational_polynomial_single_term_extraction</tabTrigger> -->
	<!-- Optional: Set a scope to limit where the snippet will trigger -->
	<scope>source.c++</scope> -->
</snippet>
