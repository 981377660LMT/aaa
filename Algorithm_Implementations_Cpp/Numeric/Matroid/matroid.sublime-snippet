<snippet>
	<content><![CDATA[
struct colorful_matroid{
	vector<bool> flag;
	vector<int> color;
	colorful_matroid(const vector<int> &color, int c): color(color), flag(c){ }
	bool check(int i){
		return !flag[color[i]];
	}
	void insert(int i){
		flag[color[i]] = true;
	}
	void clear(){
		fill(flag.begin(), flag.end(), false);
	}
};
// Requires disjoint_set
struct graphic_matroid{
	disjoint_set dsu;
	vector<array<int, 2>> e;
	graphic_matroid(int n, const vector<array<int, 2>> &e): dsu(n), e(e){ }
	bool check(int i){
		return !dsu.share(e[i][0], e[i][1]);
	}
	void insert(int i){
		dsu.merge(e[i][0], e[i][1]);
	}
	void clear(){
		dsu = {(int)dsu.p.size()};
	}
};
struct Z2_linear_matroid{
	vector<long long> elements, basis;
	Z2_linear_matroid(const vector<long long> &elements): elements(elements){ }
	long long reduce(long long x){
		for(auto y: basis) x = min(x, x ^ y);
		return x;
	}
	bool check(int i){
		return reduce(elements[i]);
	}
	void insert(int i){
		long long x = reduce(elements[i]);
		assert(x);
		basis.insert(lower_bound(basis.begin(), basis.end(), x, greater<>()), x);
	}
	void clear(){
		basis.clear();
	}
};
struct partition_matroid{
	vector<int> cnt, group, limit;
	partition_matroid(const vector<int> &group, const vector<int> &limit): cnt((int)limit.size()), group(group), limit(limit){ }
	bool check(int i){
		return cnt[group[i]] < limit[group[i]];
	}
	void insert(int i){
		++ cnt[group[i]];
	}
	void clear(){
		fill(cnt.begin(), cnt.end(), 0);
	}
};
// Skeleton of oracle
struct matroid{
	matroid(){ }
	bool check(int i){

	}
	// Only gets called when the resulting set is independent
	void insert(int i){

	}
	void clear(){
		
	}
};
]]></content>
	<!-- Optional: Set a tabTrigger to define how to trigger the snippet -->
	<tabTrigger>matroid</tabTrigger> -->
	<!-- Optional: Set a scope to limit where the snippet will trigger -->
	<scope>source.c++</scope> -->
</snippet>
