<snippet>
	<content><![CDATA[
// Matroids(M1 and M2) must have check(int), insert(int), clear() member functions
// ---------------------------------------------
// | # of member function calls where          |
// | R is the size of the answer and           |
// | N is the size of the ground set           |
// ---------------------------------------------
// | Member Function | M1         | M2         |
// ---------------------------------------------
// | insert()        | O(R^3)     | O(R^2 * N) |
// | check()         | O(R^2 * N) | O(R^2 * N) |
// | clear()         | O(R^2)     | O(R * N)   |
// ---------------------------------------------
template<class M1, class M2>
vector<int> matroid_intersection(int n, M1 m1, M2 m2){
	vector<bool> flag(n);
	for(auto i = 0; i < n; ++ i) if(m1.check(i) && m2.check(i)) flag[i] = true, m1.insert(i), m2.insert(i);
	auto augment = [&]()->bool{
		vector<int> from(n, -1);
		queue<int> q({n}); // starts at dummy node
		auto forward_edge = [&](int x){
			vector<int> res;
			m1.clear();
			for(auto i = 0; i < n; ++ i) if(flag[i] && i != x) m1.insert(i);
			for(auto i = 0; i < n; ++ i) if(!flag[i] && from[i] == -1 && m1.check(i)) res.push_back(i), from[i] = x;
			return res;
		};
		auto back_edge = [&](int x){
			m2.clear();
			for(auto rep = 0; rep < 2; ++ rep) for(auto i = 0; i < n; ++ i) if((i == x || flag[i]) && (from[i] == -1) == rep){
				if(!m2.check(i)) return rep ? q.push(i), from[i] = x, i : -1;
				m2.insert(i);
			}
			return n;
		};
		while(!q.empty()){
			int i = q.front(), j; q.pop();
			for(auto k: forward_edge(i)) while((j = back_edge(k)) >= 0) if(j == n){
				while(k != n) flag[k].flip(), k = from[k];
				return true;
			}
		}
		return false;
	};
	while(augment());
	vector<int> res;
	for(auto i = 0; i < n; ++ i) if(flag[i]) res.push_back(i);
	return res;
}
/*
struct colorful_matroid{
	vector<bool> flag;
	vector<int> color;
	colorful_matroid(const vector<int> &color, int c): color(color), flag(c){ }
	bool check(int i){
		return !flag[color[i]];
	}
	void insert(int i){
		flag[color[i]] = true;
	}
	void clear(){
		fill(flag.begin(), flag.end(), false);
	}
};
// Requires disjoint_set
struct graphic_matroid{
	disjoint_set dsu;
	vector<array<int, 2>> e;
	graphic_matroid(int n, vector<array<int, 2>> e): dsu(n), e(e){ }
	bool check(int i){
		return !dsu.share(e[i][0], e[i][1]);
	}
	void insert(int i){
		dsu.merge(e[i][0], e[i][1]);
	}
	void clear(){
		dsu = {(int)dsu.p.size()};
	}
};
struct Z2_linear_matroid{
	vector<long long> elements, basis;
	Z2_linear_matroid(const vector<long long> &elements): elements(elements){ }
	long long reduce(long long x){
		for(auto y: basis) x = min(x, x ^ y);
		return x;
	}
	bool check(int i){
		return reduce(elements[i]);
	}
	void insert(int i){
		long long x = reduce(elements[i]);
		assert(x);
		basis.insert(lower_bound(basis.begin(), basis.end(), x, greater<>()), x);
	}
	void clear(){
		basis.clear();
	}
};
struct partition_matroid{
	vector<int> cnt, group, limit;
	partition_matroid(const vector<int> &group, const vector<int> &limit): cnt((int)limit.size()), group(group), limit(limit){ }
	bool check(int i){
		return cnt[group[i]] < limit[group[i]];
	}
	void insert(int i){
		++ cnt[group[i]];
	}
	void clear(){
		fill(cnt.begin(), cnt.end(), 0);
	}
};
struct matroid{
	matroid(){ }
	bool check(int i){

	}
	// only gets called when the resulting set is independent
	void insert(int i){

	}
	void clear(){
		
	}
};
*/
]]></content>
	<!-- Optional: Set a tabTrigger to define how to trigger the snippet -->
	<tabTrigger>matroid_intersection</tabTrigger> -->
	<!-- Optional: Set a scope to limit where the snippet will trigger -->
	<scope>source.c++</scope> -->
</snippet>
