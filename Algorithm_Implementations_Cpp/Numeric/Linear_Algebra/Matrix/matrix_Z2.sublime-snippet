<snippet>
	<content><![CDATA[
template<int SZ>
struct matrix_Z2_base{
	vector<bitset<SZ>> data;
	bitset<SZ> &operator[](int i){
		assert(0 <= i && i < n);
		return data[i];
	}
	const bitset<SZ> &operator[](int i) const{
		assert(0 <= i && i < n);
		return data[i];
	}
	matrix_Z2_base &operator+=(const matrix_Z2_base &M){
		assert(n == M.n && m == M.m);
		for(auto i = 0; i < n; ++ i) data[i] ^= M[i];
		return *this;
	}
	matrix_Z2_base operator+(const matrix_Z2_base &M) const{
		matrix_Z2_base res(n, m);
		res += M;
		return res;
	}
	matrix_Z2_base operator*(const matrix_Z2_base &otr) const{
		assert(m == otr.n);
		int l = otr.m;
		matrix_Z2_base res(n, l);
		vector<bitset<SZ>> temp(l);
		for(auto i = 0; i < l; ++ i) for(auto j = 0; j < m; ++ j) temp[i][j] = otr[j][i];
		for(auto i = 0; i < n; ++ i) for(auto j = 0; j < l; ++ j) res[i][j] = (data[i] & temp[j]).count() & 1;
		return res;
	}
	matrix_Z2_base &operator*=(const matrix_Z2_base &otr){
		return *this = *this * otr;
	}
	matrix_Z2_base &operator*=(bool c){
		if(!c) for(auto &v: *this) v.reset();
		return *this;
	}
	matrix_Z2_base operator*(bool c) const{
		matrix_Z2_base res(data);
		return res *= c;
	}
	matrix_Z2_base &operator^=(long long e){
		matrix_Z2_base res(n, n, true);
		for(; e; *this *= *this, e >>= 1) if(e & 1) res *= *this;
		return *this = res;
	}
	matrix_Z2_base operator^(long long e) const{
		assert(n == m);
		matrix_Z2_base res(data); res ^= e;
		return res;
	}
	matrix_Z2_base transposed() const{
		matrix_Z2_base res(m, n);
		for(auto i = 0; i < n; ++ i) for(auto j = 0; j < m; ++ j) res[j][i] = data[i][j];
		return res;
	}
	matrix_Z2_base &transpose(){
		return *this = transposed();
	}
	bool det() const{
		assert(n == m);
		matrix_Z2_base temp(data);
		for(auto i = 0; i < n; ++ i){
			for(auto j = i + 1; j < n; ++ j) if(temp[j][i]){
				if(temp[i][i]) temp[j] ^= temp[i];
				else swap(temp[i], temp[j]);
			}
			if(!temp[i][i]) return false;
		}
		return true;
	}
	bool inverse(){
		assert(n == m);
		vector<bitset<SZ>> temp(data), res(n);
		for(auto i = 0; i < n; ++ i) res[i].set(i);
		for(auto j = 0; j < n; ++ j){
			int pivot = -1;
			for(auto i = j; i < n; ++ i) if(temp[i][j]){
				pivot = i;
				break;
			}
			if(!~pivot) return false;
			swap(temp[j], temp[pivot]), swap(res[j], res[pivot]);
			for(auto i = 0; i < n; ++ i) if(i != j && temp[i][j]) temp[i] ^= temp[j], res[i] ^= res[j];
		}
		swap(*this, res);
		return true;
	}
	matrix_Z2_base inversed() const{
		matrix_Z2_base res(data);
		res.inverse();
		return res;
	}
	vector<int> operator*(const bitset<SZ> &v) const{
		vector<int> res(n);
		for(auto i = 0; i < n; ++ i) res[i] = (data[i] & v).count() & 1;
		return res;
	}
	int n, m;
	matrix_Z2_base(int n, int m, bool init_diagonal = false, bool init_off_diagonal = false): n(n), m(m), data(n){
		for(auto i = 0; i < n; ++ i) for(auto j = 0; j < m; ++ j) data[i][j] = i == j ? init_diagonal : init_off_diagonal;
	}
	matrix_Z2_base(const vector<bitset<SZ>> &arr): n((int)arr.size()), m((int)arr[0].size()), data(arr){ }
};
template<int SZ>
matrix_Z2_base<SZ> operator*(bool c, matrix_Z2_base<SZ> M){
	if(!c) for(auto &v: M) v.reset();
	return M;
}
template<int SZ>
vector<int> operator*(const vector<int> &v, const matrix_Z2_base<SZ> &M){
	vector<int> res(M.m);
	for(auto i = 0; i < M.n; ++ i) for(auto j = 0; j < M.m; ++ j) res[j] ^= v[i] & M[i][j];
	return res;
}
template<int SZ>
vector<int> &operator*=(vector<int> &v, const matrix_Z2_base<SZ> &M){
	return v = v * M;
}
using matrix_Z2 = matrix_Z2_base<1000>;
]]></content>
	<!-- Optional: Set a tabTrigger to define how to trigger the snippet -->
	<tabTrigger>matrix_Z2</tabTrigger> -->
	<!-- Optional: Set a scope to limit where the snippet will trigger -->
	<scope>source.c++</scope> -->
</snippet>
