<snippet>
	<content><![CDATA[
// Implementation of "Determinant: Combinatorics, Algorithms, and Complexity" by Meena Mahajan
// T must be a commutative ring
// O(n^4)
template<class T>
T determinant_commutative_ring(const vector<vector<T>> &M, T T_id_add = 0, T T_id_mul = 1){
	if(M.empty()) return T_id_mul;
	int n = (int)M.size();
	assert((int)M[0].size() == n);
	array<vector<vector<T>>, 2> dp, dp_next;
	dp.fill(vector<vector<T>>(n, vector<T>(n, T_id_add)));
	dp_next = dp;
	for(auto i = 0; i < n; ++ i) dp[n & 1][i][i] = T_id_mul;
	for(auto l = 0; l < n - 1; ++ l){
		for(auto p: {0, 1}) for(auto &r: dp_next[p]) fill(r.begin(), r.end(), T_id_add);
		for(auto p = 0; p < 2; ++ p) for(auto i = 0; i < n; ++ i) for(auto j = i; j < n; ++ j){
			T delta = dp[p][i][j], delta2 = delta * M[j][i];
			for(auto k = i + 1; k < n; ++ k){
				dp_next[p][i][k] += delta * M[j][k];
				dp_next[p ^ 1][k][k] += delta2;
			}
		}
		swap(dp, dp_next);
	}
	T res = T_id_add;
	for(auto i = 0; i < n; ++ i) for(auto j = i; j < n; ++ j){
		res -= dp[0][i][j] * M[j][i];
		res += dp[1][i][j] * M[j][i];
	}
	return res;
}
]]></content>
	<!-- Optional: Set a tabTrigger to define how to trigger the snippet -->
	<tabTrigger>determinant_commutative_ring</tabTrigger> -->
	<!-- Optional: Set a scope to limit where the snippet will trigger -->
	<scope>source.c++</scope> -->
</snippet>
