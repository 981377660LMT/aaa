<snippet>
	<content><![CDATA[
struct two_sat_solver{
private:
	int n;
	vector<vector<int>> adj;
	vector<int> val, comp, z;
public:
	vector<int> value;
	two_sat_solver(int n = 0): n(n), adj(n << 1){ }
	int add_variable(){
		adj.emplace_back();
		adj.emplace_back();
		return n ++;
	}
	void either(int u, int v){
		u = max(2 * u, -1 - 2 * u);
		v = max(2 * v, -1 - 2 * v);
		adj[u].push_back(v ^ 1);
		adj[v].push_back(u ^ 1);
	}
	void implies(int u, int v){
		either(~u, v);
	}
	void equals(int u, int v){
		either(~u, v), either(u, ~v);
	}
	void differs(int u, int v){
		either(u, v), either(~u, ~v);
	}
	void set_value(int u, bool x = true){
		x ? either(u, u) : either(~u, ~u);
	}
	void at_most_one(const vector<int> &arr){
		if((int)arr.size() <= 1) return;
		int cur = ~arr[0];
		for(auto u = 2; u < (int)arr.size(); ++ u){
			int next = add_variable();
			either(cur, ~arr[u]), either(cur, next), either(~arr[u], next);
			cur = ~next;
		}
		either(cur, ~arr[1]);
	}
	int time, comp_cnt;
	int dfs(int u){
		int low = val[u] = ++ time, v;
		z.push_back(u);
		for(auto v: adj[u]) if(!~comp[v]) low = min(low, val[v] ?: dfs(v));
		++ time;
		if(low == val[u]){
			do{
				v = z.back();
				z.pop_back();
				comp[v] = comp_cnt;
				if(value[v >> 1] == -1) value[v >> 1] = v & 1;
			}while(v != u);
			comp_cnt ++;
		}
		return val[u] = low;
	}
	// O(n)
	bool solve(){
		value.assign(n, -1);
		val.assign(2 * n, 0);
		comp.assign(2 * n, -1);
		time = comp_cnt = 0;
		for(auto u = 0; u < n << 1; ++ u) if(!~comp[u]) dfs(u);
		for(auto u = 0; u < n; ++ u) if(comp[u << 1] == comp[u << 1 ^ 1]) return false;
		return true;
	}
	// Enumerate solutions while act_while() returns true.
	bool enumerate_solutions(auto act_while){
		if(!solve()) return false;
		fill(value.begin(), value.end(), -1);
		vector<int> was(n << 1, -1);
		vector<vector<int>> has(comp_cnt);
		for(auto s = 0; s < n << 1; ++ s){
			has[comp[s]].push_back(s);
			if(~value[s >> 1]) continue;
			auto dfs = [&](auto self, int u)->void{
				was[u] = s;
				for(auto v: adj[u]) if(was[v] != s) self(self, v);
			};
			dfs(dfs, s);
			if(was[s ^ 1] != s) continue;
			value[s >> 1] = ~s & 1;
			auto dfs2 = [&](auto self, int u)->void{
				for(auto v: adj[u]) if(!~value[v >> 1]){
					value[v >> 1] = v & 1;
					self(self, v);
				}
			};
			dfs2(dfs2, s ^ 1);
		}
		for(auto t = 0; t < comp_cnt; ++ t) assert(!has[t].empty());
		auto dfs = [&](auto self, int t)->bool{
			if(!~t) return act_while(value);
			int u = has[t][0];
			if(~value[u >> 1]) return self(self, t - 1);
			for(auto v: has[t]) value[v >> 1] = ~v & 1;
			if(!self(self, t - 1)) return false;
			for(auto v: has[t]) value[v >> 1] = v & 1;
			vector<int> pushed;
			auto push = [&](auto self, int u)->void{
				for(auto v: adj[u]) if(!~value[v >> 1]){
					pushed.push_back(v);
					value[v >> 1] = v & 1;
					self(self, v);
				}
			};
			push(push, u);
			if(!self(self, t - 1)) return false;
			for(auto v: has[t]) value[v >> 1] = -1;
			for(auto v: pushed) value[v >> 1] = -1;
			return true;
		};
		dfs(dfs, comp_cnt - 1);
		return true;
	}
};
]]></content>
	<!-- Optional: Set a tabTrigger to define how to trigger the snippet -->
	<tabTrigger>two_sat_solver</tabTrigger> -->
	<!-- Optional: Set a scope to limit where the snippet will trigger -->
	<scope>source.c++</scope> -->
</snippet>
