<snippet>
	<content><![CDATA[
// Requires graph
// O(|V| log |V|)
template<class T>
struct centroid_decomposition{
	int n, root; // the root of the arborescence
	graph<int> abr; // stores the arborescence
	vector<int> sz;
	vector<vector<T>> dist; // dist[u][i]: sum of weights from u to its i-th centroid parent
	T T_id;
	template<class U, class F = plus<>>
	centroid_decomposition(const graph<U> &g, T T_id = {}, F UT = plus<>()): n(g.n), abr(g.n), T_id(T_id), dist(g.n), sz(g.n){
		vector<int> dead(n), sz(n);
		auto centroid = [&](int s){
			int u = s, pe = -1;
			while(true){
				for(auto id: g.adj[u]){
					if(id == pe || g.ignore && g.ignore(id)) continue;
					auto &e = g.edge[id];
					int v = u ^ e.from ^ e.to;
					if(dead[v]) continue;
					if(sz[v] > sz[s] >> 1){
						u = v, pe = id;
						goto NEXT;
					}
				}
				break;
				NEXT:;
			}
			return u;
		};
		auto dfs_sz = [&](auto self, int u, int p)->void{
			sz[u] = 1;
			for(auto id: g.adj[u]){
				if(g.ignore && g.ignore(id)) continue;
				auto &e = g.edge[id];
				int v = u ^ e.from ^ e.to;
				if(p == v || dead[v]) continue;
				self(self, v, u);
				sz[u] += sz[v];
			}
		};
		auto set_distance = [&](auto self, int u, int pe)->void{
			int p = u ^ g.edge[pe].from ^ g.edge[pe].to;
			dist[u].push_back(UT(g.edge[pe].cost, dist[p].back()));
			for(auto id: g.adj[u]){
				if(id == pe || g.ignore && g.ignore(id)) continue;
				auto &e = g.edge[id];
				int v = u ^ e.from ^ e.to;
				if(dead[v]) continue;
				self(self, v, id);
			}
		};
		auto construct = [&](auto self, int u, int p)->void{
			dfs_sz(dfs_sz, u, p);
			dead[u = centroid(u)] = true;
			this->sz[u] = sz[u];
			if(~p) abr.orient(p, u);
			else root = u;
			dist[u].push_back(T_id);
			for(auto id: g.adj[u]){
				auto &e = g.edge[id];
				int v = u ^ e.from ^ e.to;
				if(!dead[v]) set_distance(set_distance, v, id);
			}
			for(auto id: g.adj[u]){
				auto &e = g.edge[id];
				int v = u ^ e.from ^ e.to;
				if(!dead[v]) self(self, v, u);
			}
		};
		construct(construct, 0, -1);
		for(auto u = 0; u < n; ++ u) reverse(dist[u].begin(), dist[u].end());
	}
};
]]></content>
	<!-- Optional: Set a tabTrigger to define how to trigger the snippet -->
	<tabTrigger>centroid_decomposition</tabTrigger> -->
	<!-- Optional: Set a scope to limit where the snippet will trigger -->
	<scope>source.c++</scope> -->
</snippet>
