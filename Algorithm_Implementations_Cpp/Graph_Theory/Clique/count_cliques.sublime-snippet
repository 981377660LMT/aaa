<snippet>
	<content><![CDATA[
// Returns the sum of the product of vertex weights over all cliques.
// O(2^(n / 2) * n + m)
template<class T, class M = unsigned long long>
T count_cliques(const vector<M> &adjm, vector<T> w = {}){
	int n = (int)adjm.size();
	assert(n <= 64);
	if(n == 0) return 0;
	if(w.empty()) w.resize(n, 1);
	assert((int)w.size() == n);
	if(n == 1) return w[0];
	int h = n + 3 >> 1;
	static vector<T> sum;
	sum.assign(1 << n - h, 0);
	for(auto mask = 0; mask < 1 << n - h; ++ mask){
		M adjmask = 0;
		T prod = 1;
		for(auto u = h; u < n; ++ u){
			adjmask |= adjm[u] >> h;
			if(mask & 1 << u - h) prod *= w[u];
		}
		if(adjmask == mask) sum[mask] += prod;
	}
	for(auto u = h; u < n; ++ u) for(auto mask = 0; mask < 1 << n - h; ++ mask) if(mask & 1 << u - h) sum[mask] += sum[mask ^ 1 << u - h];
	static vector<tuple<unsigned int, T, int, M>> stack;
	stack.resize(1 << h + 1);
	stack[0] = {0, 1, 0, (1 << h) - 1};
	T res = 0;
	const unsigned int full_mask = (1 << h) - 1;
	for(auto is = 0; is >= 0; ){
		auto [mask, prod, u, cadj] = stack[is --];
		if(u == h && (cadj & full_mask) == full_mask){
			res += prod * sum[cadj >> h];
			continue;
		}
		stack[++ is] = {mask, prod, u + 1, cadj};
		stack[++ is] = {mask | 1u << u, prod * w[u], u + 1, cadj & adjm[u]};
	}
	return res;
}
]]></content>
	<!-- Optional: Set a tabTrigger to define how to trigger the snippet -->
	<tabTrigger>count_cliques</tabTrigger> -->
	<!-- Optional: Set a scope to limit where the snippet will trigger -->
	<scope>source.c++</scope> -->
</snippet>
