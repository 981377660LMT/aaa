<snippet>
	<content><![CDATA[
// Requires range_minmax_query_solver
struct suffix_array{
	template<class T>
	void compute_lcp(const vector<T> &s){
		assert(1 <= n);
		rank.resize(n), lcp.resize(n - 1);
		for(auto i = 0; i < n; ++ i) rank[sa[i]] = i;
		for(auto i = 0, h = 0; i < n; ++ i){
			if(h > 0) -- h;
			if(rank[i] == 0) continue;
			int j = sa[rank[i] - 1];
			for(; j + h < n && i + h < n; ++ h) if(s[j + h] != s[i + h]) break;
			lcp[rank[i] - 1] = h;
		}
		rmq = range_minmax_query_solver(lcp);
	} // O(n log n)
	vector<int> sa_naive(const vector<int> &s){
		int n = (int)s.size();
		vector<int> sa(n);
		iota(sa.begin(), sa.end(), 0);
		sort(sa.begin(), sa.end(), [&](int l, int r){
			if(l == r) return false;
			for(; l < n && r < n; ++ l, ++ r) if(s[l] != s[r]) return s[l] < s[r];
			return l == n;
		});
		return sa;
	}
	vector<int> sa_doubling(const vector<int> &s){
		int n = (int)s.size();
		vector<int> sa(n), rank = s, tmp(n);
		iota(sa.begin(), sa.end(), 0);
		for(auto k = 1; k < n; k <<= 1){
			auto cmp = [&](int x, int y){
				if(rank[x] != rank[y]) return rank[x] < rank[y];
				int rx = x + k < n ? rank[x + k] : -1;
				int ry = y + k < n ? rank[y + k] : -1;
				return rx < ry;
			};
			sort(sa.begin(), sa.end(), cmp);
			tmp[sa[0]] = 0;
			for(auto i = 1; i < n; ++ i) tmp[sa[i]] = tmp[sa[i - 1]] + (cmp(sa[i - 1], sa[i]) ? 1 : 0);
			swap(tmp, rank);
		}
		return sa;
	}
	template<int THRESHOLD_NAIVE = 10, int THRESHOLD_DOUBLING = 40>
	vector<int> sa_is(const vector<int> &s, int upper){
		int n = (int)s.size();
		if(n == 0) return {};
		if(n == 1) return {0};
		if(n == 2){
			if(s[0] < s[1]) return {0, 1};
			else return {1, 0};
		}
		if(n < THRESHOLD_NAIVE) return sa_naive(s);
		if(n < THRESHOLD_DOUBLING) return sa_doubling(s);
		vector<int> sa(n);
		vector<bool> ls(n);
		for(auto i = n - 2; i >= 0; -- i) ls[i] = (s[i] == s[i + 1]) ? ls[i + 1] : (s[i] < s[i + 1]);
		vector<int> sum_l(upper), sum_s(upper);
		for(auto i = 0; i < n; ++ i){
			if(!ls[i]) ++ sum_s[s[i]];
			else ++ sum_l[s[i] + 1];
		}
		for(auto i = 0; i < upper; ++ i){
			sum_s[i] += sum_l[i];
			if(i + 1 < upper) sum_l[i + 1] += sum_s[i];
		}
		auto induce = [&](const vector<int> &lms){
			fill(sa.begin(), sa.end(), -1);
			vector<int> buf(upper);
			copy(sum_s.begin(), sum_s.end(), buf.begin());
			for(auto d: lms){
				if(d == n) continue;
				sa[buf[s[d]] ++] = d;
			}
			copy(sum_l.begin(), sum_l.end(), buf.begin());
			sa[buf[s[n - 1]] ++] = n - 1;
			for(auto i = 0; i < n; ++ i){
				int v = sa[i];
				if(v >= 1 && !ls[v - 1]) sa[buf[s[v - 1]] ++] = v - 1;
			}
			copy(sum_l.begin(), sum_l.end(), buf.begin());
			for(auto i = n - 1; i >= 0; -- i){
				int v = sa[i];
				if(v >= 1 && ls[v - 1]) sa[-- buf[s[v - 1] + 1]] = v - 1;
			}
		};
		vector<int> lms_map(n + 1, -1);
		int m = 0;
		for(auto i = 1; i < n; ++ i) if(!ls[i - 1] && ls[i]) lms_map[i] = m ++;
		vector<int> lms;
		lms.reserve(m);
		for(auto i = 1; i < n; ++ i) if(!ls[i - 1] && ls[i]) lms.push_back(i);
		induce(lms);
		if(m){
			vector<int> sorted_lms;
			sorted_lms.reserve(m);
			for(auto v: sa) if(lms_map[v] != -1) sorted_lms.push_back(v);
			vector<int> rec_s(m);
			int rec_upper = 0;
			rec_s[lms_map[sorted_lms[0]]] = 0;
			for(auto i = 1; i < m; ++ i){
				int l = sorted_lms[i - 1], r = sorted_lms[i];
				int end_l = (lms_map[l] + 1 < m) ? lms[lms_map[l] + 1] : n;
				int end_r = (lms_map[r] + 1 < m) ? lms[lms_map[r] + 1] : n;
				bool same = true;
				if(end_l - l != end_r - r) same = false;
				else{
					for(; l < end_l; ++ l, ++ r) if (s[l] != s[r]) break;
					if(l == n || s[l] != s[r]) same = false;
				}
				if(!same) ++ rec_upper;
				rec_s[lms_map[sorted_lms[i]]] = rec_upper;
			}
			auto rec_sa = sa_is<THRESHOLD_NAIVE, THRESHOLD_DOUBLING>(rec_s, rec_upper + 1);
			for(auto i = 0; i < m; ++ i) sorted_lms[i] = lms[rec_sa[i]];
			induce(sorted_lms);
		}
		return sa;
	}
	int n;
	vector<int> sa, rank, lcp;
	range_minmax_query_solver<int> rmq;
	suffix_array(const vector<int> &s, int upper, bool prepare_lcp): n((int)s.size()){
		assert(0 <= upper);
		for(auto d: s) assert(0 <= d && d < upper);
		sa = sa_is(s, upper);
		if(prepare_lcp) compute_lcp(s);
	} // O(n + upper) without compute_lcp
	template<class T>
	suffix_array(const vector<T> &s, bool prepare_lcp): n((int)s.size()){
		vector<int> idx(n);
		iota(idx.begin(), idx.end(), 0);
		sort(idx.begin(), idx.end(), [&](int l, int r){ return s[l] < s[r]; });
		vector<int> s2(n);
		int now = 0;
		for(auto i = 0; i < n; ++ i){
			if(i && s[idx[i - 1]] != s[idx[i]]) ++ now;
			s2[idx[i]] = now;
		}
		sa = sa_is(s2, now + 1);
		if(prepare_lcp) compute_lcp(s);
	} // O(n log n) time, O(n) space without compute_lcp
	int query(int i, int j){
		if(i == j) return n - i;
		return rmq.query(min(rank[i], rank[j]), max(rank[i], rank[j]));
	}
};
]]></content>
	<!-- Optional: Set a tabTrigger to define how to trigger the snippet -->
	<tabTrigger>suffix_array</tabTrigger> -->
	<!-- Optional: Set a scope to limit where the snippet will trigger -->
	<scope>source.c++</scope> -->
</snippet>
