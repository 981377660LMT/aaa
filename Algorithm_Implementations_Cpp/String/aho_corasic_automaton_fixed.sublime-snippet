<snippet>
	<content><![CDATA[
// Note: construction of an AC-automaton is offline.
// O(sigma * (sum of length)) where sigma is the size of alphabets
// All alphabets must be within [0, sigma)
template<class Char_Type, int sigma>
struct aho_corasic_automaton_fixed{
	// Begin States
	vector<int> len{0}, link{-1}, exit_link{-1}, is_terminal{false};
	vector<array<int, sigma>> next{{}};
	// End States
	int new_state(){
		len.push_back(0);
		link.push_back(-1);
		exit_link.push_back(-1);
		is_terminal.push_back(false);
		next.push_back({});
		return (int)len.size() - 1;
	}
	aho_corasic_automaton_fixed(){ }
	aho_corasic_automaton_fixed(const vector<vector<Char_Type>> &patterns){
		for(auto s: patterns){
			int u = 0;
			for(auto c: s){
				if(!next[u][c]) next[u][c] = new_state(), len[next[u][c]] = len[u] + 1;
				u = next[u][c];
			}
			is_terminal[u] = true;
		}
		deque<int> dq{0};
		while(!dq.empty()){
			int u = dq.front(); dq.pop_front();
			for(auto c = 0; c < sigma; ++ c){
				int v = next[u][c];
				if(!v) continue;
				link[v] = !~link[u] ? 0 : next[link[u]][c];
				exit_link[v] = is_terminal[link[v]] ? link[v] : exit_link[link[v]];
				dq.push_back(v); 
			}
			if(u) for(auto c = 0; c < sigma; ++ c) if(!next[u][c]) next[u][c] = next[link[u]][c];
		}
	}
	int next_state(int u, Char_Type c) const{
		return !~u ? 0 : next[u][c];
	}
	int size() const{ // # of states
		return (int)len.size();
	}
};
]]></content>
	<!-- Optional: Set a tabTrigger to define how to trigger the snippet -->
	<tabTrigger>aho_corasic_automaton_fixed</tabTrigger> -->
	<!-- Optional: Set a scope to limit where the snippet will trigger -->
	<scope>source.c++</scope> -->
</snippet>
